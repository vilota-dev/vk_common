// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: cameraintrinsic.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000002
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(9b3437ed6337ecfa);
CAPNP_DECLARE_SCHEMA(991a938a54a02769);
CAPNP_DECLARE_SCHEMA(e9635da0775d9d96);
CAPNP_DECLARE_SCHEMA(9ca01166a5c20bd2);
CAPNP_DECLARE_SCHEMA(a29470ac9c8a417e);

}  // namespace schemas
}  // namespace capnp

namespace vkc {

struct PinholeModel {
  PinholeModel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9b3437ed6337ecfa, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct DoubleSphereModel {
  DoubleSphereModel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(991a938a54a02769, 1, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct KB4Model {
  KB4Model() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e9635da0775d9d96, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct RadtanModel {
  RadtanModel() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ca01166a5c20bd2, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct CameraIntrinsic {
  CameraIntrinsic() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a29470ac9c8a417e, 2, 3)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class PinholeModel::Reader {
public:
  typedef PinholeModel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getFx() const;

  inline float getFy() const;

  inline float getCx() const;

  inline float getCy() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class PinholeModel::Builder {
public:
  typedef PinholeModel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getFx();
  inline void setFx(float value);

  inline float getFy();
  inline void setFy(float value);

  inline float getCx();
  inline void setCx(float value);

  inline float getCy();
  inline void setCy(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class PinholeModel::Pipeline {
public:
  typedef PinholeModel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class DoubleSphereModel::Reader {
public:
  typedef DoubleSphereModel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPinhole() const;
  inline  ::vkc::PinholeModel::Reader getPinhole() const;

  inline float getXi() const;

  inline float getAlpha() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class DoubleSphereModel::Builder {
public:
  typedef DoubleSphereModel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPinhole();
  inline  ::vkc::PinholeModel::Builder getPinhole();
  inline void setPinhole( ::vkc::PinholeModel::Reader value);
  inline  ::vkc::PinholeModel::Builder initPinhole();
  inline void adoptPinhole(::capnp::Orphan< ::vkc::PinholeModel>&& value);
  inline ::capnp::Orphan< ::vkc::PinholeModel> disownPinhole();

  inline float getXi();
  inline void setXi(float value);

  inline float getAlpha();
  inline void setAlpha(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class DoubleSphereModel::Pipeline {
public:
  typedef DoubleSphereModel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vkc::PinholeModel::Pipeline getPinhole();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class KB4Model::Reader {
public:
  typedef KB4Model Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPinhole() const;
  inline  ::vkc::PinholeModel::Reader getPinhole() const;

  inline float getK1() const;

  inline float getK2() const;

  inline float getK3() const;

  inline float getK4() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class KB4Model::Builder {
public:
  typedef KB4Model Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPinhole();
  inline  ::vkc::PinholeModel::Builder getPinhole();
  inline void setPinhole( ::vkc::PinholeModel::Reader value);
  inline  ::vkc::PinholeModel::Builder initPinhole();
  inline void adoptPinhole(::capnp::Orphan< ::vkc::PinholeModel>&& value);
  inline ::capnp::Orphan< ::vkc::PinholeModel> disownPinhole();

  inline float getK1();
  inline void setK1(float value);

  inline float getK2();
  inline void setK2(float value);

  inline float getK3();
  inline void setK3(float value);

  inline float getK4();
  inline void setK4(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class KB4Model::Pipeline {
public:
  typedef KB4Model Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vkc::PinholeModel::Pipeline getPinhole();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class RadtanModel::Reader {
public:
  typedef RadtanModel Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class RadtanModel::Builder {
public:
  typedef RadtanModel Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class RadtanModel::Pipeline {
public:
  typedef RadtanModel Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class CameraIntrinsic::Reader {
public:
  typedef CameraIntrinsic Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPinhole() const;
  inline  ::vkc::PinholeModel::Reader getPinhole() const;

  inline bool hasDs() const;
  inline  ::vkc::DoubleSphereModel::Reader getDs() const;

  inline bool hasKb4() const;
  inline  ::vkc::KB4Model::Reader getKb4() const;

  inline bool getRectified() const;

  inline  ::uint64_t getLastModified() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class CameraIntrinsic::Builder {
public:
  typedef CameraIntrinsic Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPinhole();
  inline  ::vkc::PinholeModel::Builder getPinhole();
  inline void setPinhole( ::vkc::PinholeModel::Reader value);
  inline  ::vkc::PinholeModel::Builder initPinhole();
  inline void adoptPinhole(::capnp::Orphan< ::vkc::PinholeModel>&& value);
  inline ::capnp::Orphan< ::vkc::PinholeModel> disownPinhole();

  inline bool hasDs();
  inline  ::vkc::DoubleSphereModel::Builder getDs();
  inline void setDs( ::vkc::DoubleSphereModel::Reader value);
  inline  ::vkc::DoubleSphereModel::Builder initDs();
  inline void adoptDs(::capnp::Orphan< ::vkc::DoubleSphereModel>&& value);
  inline ::capnp::Orphan< ::vkc::DoubleSphereModel> disownDs();

  inline bool hasKb4();
  inline  ::vkc::KB4Model::Builder getKb4();
  inline void setKb4( ::vkc::KB4Model::Reader value);
  inline  ::vkc::KB4Model::Builder initKb4();
  inline void adoptKb4(::capnp::Orphan< ::vkc::KB4Model>&& value);
  inline ::capnp::Orphan< ::vkc::KB4Model> disownKb4();

  inline bool getRectified();
  inline void setRectified(bool value);

  inline  ::uint64_t getLastModified();
  inline void setLastModified( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class CameraIntrinsic::Pipeline {
public:
  typedef CameraIntrinsic Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::vkc::PinholeModel::Pipeline getPinhole();
  inline  ::vkc::DoubleSphereModel::Pipeline getDs();
  inline  ::vkc::KB4Model::Pipeline getKb4();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline float PinholeModel::Reader::getFx() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float PinholeModel::Builder::getFx() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void PinholeModel::Builder::setFx(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float PinholeModel::Reader::getFy() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float PinholeModel::Builder::getFy() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void PinholeModel::Builder::setFy(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float PinholeModel::Reader::getCx() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float PinholeModel::Builder::getCx() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void PinholeModel::Builder::setCx(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float PinholeModel::Reader::getCy() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float PinholeModel::Builder::getCy() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void PinholeModel::Builder::setCy(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool DoubleSphereModel::Reader::hasPinhole() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool DoubleSphereModel::Builder::hasPinhole() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::vkc::PinholeModel::Reader DoubleSphereModel::Reader::getPinhole() const {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::vkc::PinholeModel::Builder DoubleSphereModel::Builder::getPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vkc::PinholeModel::Pipeline DoubleSphereModel::Pipeline::getPinhole() {
  return  ::vkc::PinholeModel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void DoubleSphereModel::Builder::setPinhole( ::vkc::PinholeModel::Reader value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::vkc::PinholeModel::Builder DoubleSphereModel::Builder::initPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void DoubleSphereModel::Builder::adoptPinhole(
    ::capnp::Orphan< ::vkc::PinholeModel>&& value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vkc::PinholeModel> DoubleSphereModel::Builder::disownPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float DoubleSphereModel::Reader::getXi() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float DoubleSphereModel::Builder::getXi() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void DoubleSphereModel::Builder::setXi(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float DoubleSphereModel::Reader::getAlpha() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float DoubleSphereModel::Builder::getAlpha() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void DoubleSphereModel::Builder::setAlpha(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool KB4Model::Reader::hasPinhole() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool KB4Model::Builder::hasPinhole() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::vkc::PinholeModel::Reader KB4Model::Reader::getPinhole() const {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::vkc::PinholeModel::Builder KB4Model::Builder::getPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vkc::PinholeModel::Pipeline KB4Model::Pipeline::getPinhole() {
  return  ::vkc::PinholeModel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void KB4Model::Builder::setPinhole( ::vkc::PinholeModel::Reader value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::vkc::PinholeModel::Builder KB4Model::Builder::initPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void KB4Model::Builder::adoptPinhole(
    ::capnp::Orphan< ::vkc::PinholeModel>&& value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vkc::PinholeModel> KB4Model::Builder::disownPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float KB4Model::Reader::getK1() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float KB4Model::Builder::getK1() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void KB4Model::Builder::setK1(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float KB4Model::Reader::getK2() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float KB4Model::Builder::getK2() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void KB4Model::Builder::setK2(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float KB4Model::Reader::getK3() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float KB4Model::Builder::getK3() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void KB4Model::Builder::setK3(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float KB4Model::Reader::getK4() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float KB4Model::Builder::getK4() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void KB4Model::Builder::setK4(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline bool CameraIntrinsic::Reader::hasPinhole() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool CameraIntrinsic::Builder::hasPinhole() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::vkc::PinholeModel::Reader CameraIntrinsic::Reader::getPinhole() const {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::vkc::PinholeModel::Builder CameraIntrinsic::Builder::getPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vkc::PinholeModel::Pipeline CameraIntrinsic::Pipeline::getPinhole() {
  return  ::vkc::PinholeModel::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void CameraIntrinsic::Builder::setPinhole( ::vkc::PinholeModel::Reader value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::vkc::PinholeModel::Builder CameraIntrinsic::Builder::initPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void CameraIntrinsic::Builder::adoptPinhole(
    ::capnp::Orphan< ::vkc::PinholeModel>&& value) {
  ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vkc::PinholeModel> CameraIntrinsic::Builder::disownPinhole() {
  return ::capnp::_::PointerHelpers< ::vkc::PinholeModel>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool CameraIntrinsic::Reader::hasDs() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool CameraIntrinsic::Builder::hasDs() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::vkc::DoubleSphereModel::Reader CameraIntrinsic::Reader::getDs() const {
  return ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::vkc::DoubleSphereModel::Builder CameraIntrinsic::Builder::getDs() {
  return ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vkc::DoubleSphereModel::Pipeline CameraIntrinsic::Pipeline::getDs() {
  return  ::vkc::DoubleSphereModel::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void CameraIntrinsic::Builder::setDs( ::vkc::DoubleSphereModel::Reader value) {
  ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::vkc::DoubleSphereModel::Builder CameraIntrinsic::Builder::initDs() {
  return ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void CameraIntrinsic::Builder::adoptDs(
    ::capnp::Orphan< ::vkc::DoubleSphereModel>&& value) {
  ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vkc::DoubleSphereModel> CameraIntrinsic::Builder::disownDs() {
  return ::capnp::_::PointerHelpers< ::vkc::DoubleSphereModel>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool CameraIntrinsic::Reader::hasKb4() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool CameraIntrinsic::Builder::hasKb4() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::vkc::KB4Model::Reader CameraIntrinsic::Reader::getKb4() const {
  return ::capnp::_::PointerHelpers< ::vkc::KB4Model>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::vkc::KB4Model::Builder CameraIntrinsic::Builder::getKb4() {
  return ::capnp::_::PointerHelpers< ::vkc::KB4Model>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::vkc::KB4Model::Pipeline CameraIntrinsic::Pipeline::getKb4() {
  return  ::vkc::KB4Model::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void CameraIntrinsic::Builder::setKb4( ::vkc::KB4Model::Reader value) {
  ::capnp::_::PointerHelpers< ::vkc::KB4Model>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::vkc::KB4Model::Builder CameraIntrinsic::Builder::initKb4() {
  return ::capnp::_::PointerHelpers< ::vkc::KB4Model>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void CameraIntrinsic::Builder::adoptKb4(
    ::capnp::Orphan< ::vkc::KB4Model>&& value) {
  ::capnp::_::PointerHelpers< ::vkc::KB4Model>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::vkc::KB4Model> CameraIntrinsic::Builder::disownKb4() {
  return ::capnp::_::PointerHelpers< ::vkc::KB4Model>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool CameraIntrinsic::Reader::getRectified() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool CameraIntrinsic::Builder::getRectified() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void CameraIntrinsic::Builder::setRectified(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t CameraIntrinsic::Reader::getLastModified() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t CameraIntrinsic::Builder::getLastModified() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void CameraIntrinsic::Builder::setLastModified( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

}  // namespace

CAPNP_END_HEADER

